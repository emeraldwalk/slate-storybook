{
  "/stories/components/NodeSelector.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story, Meta } from '@storybook/react'\\nimport { NodeSelector, NodeSelectorProps } from '../../components'\\nimport { SlateContextDecorator } from '../util'\\nimport { mockParagraphsAndList } from '../util/mockData'\\nimport { Path, Point } from 'slate'\\n\\nexport default {\\n  title: 'Storybook/Components/NodeSelector',\\n  component: NodeSelector,\\n  decorators: [\\n    (Story, context) => {\\n      return (\\n        <SlateContextDecorator\\n          story={Story}\\n          initialSlateValue={context.parameters.initialSlateValue}\\n        />\\n      )\\n    },\\n  ],\\n} as Meta\\n\\nconst Template: Story<NodeSelectorProps<'path' | 'point'>> = (args) => {\\n  const [value, setValue] = React.useState<Path | Point | undefined>(undefined)\\n  return <NodeSelector {...args} value={value} onChange={setValue} />\\n}\\n\\nexport const PathSelector = Template.bind({})\\nPathSelector.args = {\\n  mode: 'path',\\n}\\nPathSelector.parameters = {\\n  initialSlateValue: mockParagraphsAndList,\\n}\\n\\nexport const PointSelector = Template.bind({})\\nPointSelector.args = {\\n  mode: 'point',\\n}\\nPointSelector.parameters = {\\n  initialSlateValue: mockParagraphsAndList,\\n}\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"PathSelector\":{\"startLoc\":{\"col\":61,\"line\":23},\"endLoc\":{\"col\":1,\"line\":26},\"startBody\":{\"col\":61,\"line\":23},\"endBody\":{\"col\":1,\"line\":26}},\"PointSelector\":{\"startLoc\":{\"col\":61,\"line\":23},\"endLoc\":{\"col\":1,\"line\":26},\"startBody\":{\"col\":61,\"line\":23},\"endBody\":{\"col\":1,\"line\":26}}};\n    \nimport React from 'react'\nimport { Story, Meta } from '@storybook/react'\nimport { NodeSelector, NodeSelectorProps } from '../../components'\nimport { SlateContextDecorator } from '../util'\nimport { mockParagraphsAndList } from '../util/mockData'\nimport { Path, Point } from 'slate'\n\nexport default {\n  title: 'Storybook/Components/NodeSelector',\n  component: NodeSelector,\n  decorators: [\n    (Story, context) => {\n      return (\n        <SlateContextDecorator\n          story={Story}\n          initialSlateValue={context.parameters.initialSlateValue}\n        />\n      )\n    },\n  ],\n} as Meta\n\nconst Template: Story<NodeSelectorProps<'path' | 'point'>> = (args) => {\n  const [value, setValue] = React.useState<Path | Point | undefined>(undefined)\n  return <NodeSelector {...args} value={value} onChange={setValue} />\n}\n\nexport const PathSelector = Template.bind({});\nPathSelector.args = {\n  mode: 'path',\n}\nPathSelector.parameters = {\n  initialSlateValue: mockParagraphsAndList,\n}\n\nexport const PointSelector = Template.bind({});PointSelector.args = {\n  mode: 'point',\n}\nPointSelector.parameters = {\n  initialSlateValue: mockParagraphsAndList,\n}\n\n\n\nPathSelector.parameters = { storySource: { source: \"(args) => {\\n  const [value, setValue] = React.useState<Path | Point | undefined>(undefined)\\n  return <NodeSelector {...args} value={value} onChange={setValue} />\\n}\" }, ...PathSelector.parameters };\nPointSelector.parameters = { storySource: { source: \"(args) => {\\n  const [value, setValue] = React.useState<Path | Point | undefined>(undefined)\\n  return <NodeSelector {...args} value={value} onChange={setValue} />\\n}\" }, ...PointSelector.parameters };",
  "/stories/Editor/Concepts.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story, Meta } from '@storybook/react'\\n// import EditorWithSpellcheck, {\\n//   EditorWithSpellcheckProps,\\n// } from './EditorWithSpellcheck'\\nimport EditorWithDecorations, {\\n  EditorWithDecorationsProps,\\n} from './EditorWithDecorations'\\n\\nconst meta: Meta = {\\n  title: 'Slate/Concepts',\\n  component: EditorWithDecorations,\\n  argTypes: {\\n    initialValue: { control: 'object' },\\n  },\\n}\\n\\nexport default meta\\n\\n/** Templates */\\n\\n// const SpellcheckTemplate: Story<EditorWithSpellcheckProps> = (args) => (\\n//   <EditorWithSpellcheck {...args} />\\n// )\\nconst DecorationsTemplate: Story<EditorWithDecorationsProps> = (args) => (\\n  <EditorWithDecorations {...args} />\\n)\\n\\nconst emptyValue = () => [\\n  {\\n    children: [{ text: '' }],\\n  },\\n]\\n\\nexport const Decorations = DecorationsTemplate.bind({})\\nDecorations.args = {\\n  initialValue: emptyValue(),\\n}\\nDecorations.parameters = {\\n  actions: {\\n    disable: true,\\n  },\\n  // docs: {\\n  //   page: null,\\n  // },\\n  previewTabs: {\\n    'storybook/docs/panel': {\\n      hidden: true,\\n    },\\n  },\\n  sourceCodeAddon: {\\n    sourcePath: '/stories/Editor/EditorWithDecorations.tsx',\\n  },\\n}\\n\\n// export const CustomSpellcheck = SpellcheckTemplate.bind({})\\n// CustomSpellcheck.args = {\\n//   initialValue: emptyValue(),\\n// }\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"Decorations\":{\"startLoc\":{\"col\":63,\"line\":25},\"endLoc\":{\"col\":1,\"line\":27},\"startBody\":{\"col\":63,\"line\":25},\"endBody\":{\"col\":1,\"line\":27}}};\n    \nimport React from 'react'\nimport { Story, Meta } from '@storybook/react'\n// import EditorWithSpellcheck, {\n//   EditorWithSpellcheckProps,\n// } from './EditorWithSpellcheck'\nimport EditorWithDecorations, {\n  EditorWithDecorationsProps,\n} from './EditorWithDecorations'\n\nconst meta: Meta = {\n  title: 'Slate/Concepts',\n  component: EditorWithDecorations,\n  argTypes: {\n    initialValue: { control: 'object' },\n  },\n}\n\nexport default meta\n\n/** Templates */\n\n// const SpellcheckTemplate: Story<EditorWithSpellcheckProps> = (args) => (\n//   <EditorWithSpellcheck {...args} />\n// )\nconst DecorationsTemplate: Story<EditorWithDecorationsProps> = (args) => (\n  <EditorWithDecorations {...args} />\n)\n\nconst emptyValue = () => [\n  {\n    children: [{ text: '' }],\n  },\n]\n\nexport const Decorations = DecorationsTemplate.bind({});Decorations.args = {\n  initialValue: emptyValue(),\n}\nDecorations.parameters = {\n  actions: {\n    disable: true,\n  },\n  // docs: {\n  //   page: null,\n  // },\n  previewTabs: {\n    'storybook/docs/panel': {\n      hidden: true,\n    },\n  },\n  sourceCodeAddon: {\n    sourcePath: '/stories/Editor/EditorWithDecorations.tsx',\n  },\n}\n\n// export const CustomSpellcheck = SpellcheckTemplate.bind({})\n// CustomSpellcheck.args = {\n//   initialValue: emptyValue(),\n// }\n\n\n\nDecorations.parameters = { storySource: { source: \"(args) => (\\n  <EditorWithDecorations {...args} />\\n)\" }, ...Decorations.parameters };",
  "/stories/components/ApiControls.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story, Meta } from '@storybook/react'\\nimport { ApiControls, ApiControlsProps } from '../../components'\\nimport { NodeSpecContextDecorator } from '../util'\\nimport { mockParagraphsAndList } from '../util/mockData'\\nimport { editorApiFunctions } from '../util/api'\\nimport { useArgValues } from '../../components/ApiControls/model'\\n\\nexport default {\\n  title: 'Storybook/Components/ApiControls',\\n  component: ApiControls,\\n  decorators: [\\n    (Story, context) => {\\n      return (\\n        <NodeSpecContextDecorator\\n          story={Story}\\n          initialSlateValue={context.parameters.initialSlateValue}\\n        />\\n      )\\n    },\\n  ],\\n  parameters: {\\n    options: {\\n      showPanel: true,\\n    },\\n  },\\n} as Meta\\n\\nconst Template: Story<ApiControlsProps> = ({ apiFunction, onChange }) => {\\n  const { values, setValues } = useArgValues(apiFunction.args)\\n  const onChangeInternal = React.useCallback(\\n    (values) => {\\n      setValues(values)\\n      onChange(values)\\n    },\\n    [onChange, setValues]\\n  )\\n  return (\\n    <ApiControls\\n      apiFunction={apiFunction}\\n      values={values}\\n      onChange={onChangeInternal}\\n    />\\n  )\\n}\\n\\nexport const ApiControlsDefault = Template.bind({})\\nApiControlsDefault.parameters = {\\n  initialSlateValue: mockParagraphsAndList,\\n}\\nApiControlsDefault.args = {\\n  apiFunction: editorApiFunctions.path,\\n  values: [],\\n}\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"ApiControlsDefault\":{\"startLoc\":{\"col\":42,\"line\":29},\"endLoc\":{\"col\":1,\"line\":45},\"startBody\":{\"col\":42,\"line\":29},\"endBody\":{\"col\":1,\"line\":45}}};\n    \nimport React from 'react'\nimport { Story, Meta } from '@storybook/react'\nimport { ApiControls, ApiControlsProps } from '../../components'\nimport { NodeSpecContextDecorator } from '../util'\nimport { mockParagraphsAndList } from '../util/mockData'\nimport { editorApiFunctions } from '../util/api'\nimport { useArgValues } from '../../components/ApiControls/model'\n\nexport default {\n  title: 'Storybook/Components/ApiControls',\n  component: ApiControls,\n  decorators: [\n    (Story, context) => {\n      return (\n        <NodeSpecContextDecorator\n          story={Story}\n          initialSlateValue={context.parameters.initialSlateValue}\n        />\n      )\n    },\n  ],\n  parameters: {\n    options: {\n      showPanel: true,\n    },\n  },\n} as Meta\n\nconst Template: Story<ApiControlsProps> = ({ apiFunction, onChange }) => {\n  const { values, setValues } = useArgValues(apiFunction.args)\n  const onChangeInternal = React.useCallback(\n    (values) => {\n      setValues(values)\n      onChange(values)\n    },\n    [onChange, setValues]\n  )\n  return (\n    <ApiControls\n      apiFunction={apiFunction}\n      values={values}\n      onChange={onChangeInternal}\n    />\n  )\n}\n\nexport const ApiControlsDefault = Template.bind({});ApiControlsDefault.parameters = {\n  initialSlateValue: mockParagraphsAndList,\n}\nApiControlsDefault.args = {\n  apiFunction: editorApiFunctions.path,\n  values: [],\n}\n\n\n\nApiControlsDefault.parameters = { storySource: { source: \"({ apiFunction, onChange }) => {\\n  const { values, setValues } = useArgValues(apiFunction.args)\\n  const onChangeInternal = React.useCallback(\\n    (values) => {\\n      setValues(values)\\n      onChange(values)\\n    },\\n    [onChange, setValues]\\n  )\\n  return (\\n    <ApiControls\\n      apiFunction={apiFunction}\\n      values={values}\\n      onChange={onChangeInternal}\\n    />\\n  )\\n}\" }, ...ApiControlsDefault.parameters };",
  "/stories/components/NodeSpec.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story, Meta } from '@storybook/react'\\nimport { NodeSpec, NodeSpecProps } from '../../components'\\nimport { SlateContextDecorator } from '../util'\\nimport { mockParagraphsAndList } from '../util/mockData'\\n\\nexport default {\\n  title: 'Storybook/Components/NodeSpec',\\n  component: NodeSpec,\\n  decorators: [\\n    (Story, context) => {\\n      return (\\n        <SlateContextDecorator\\n          story={Story}\\n          initialSlateValue={context.parameters.initialSlateValue}\\n        />\\n      )\\n    },\\n  ],\\n  parameters: {\\n    initialSlateValue: mockParagraphsAndList,\\n  },\\n} as Meta\\n\\nconst Template: Story<NodeSpecProps> = (args) => <NodeSpec {...args} />\\n\\nexport const NodeSpecPath = Template.bind({})\\nNodeSpecPath.args = {\\n  mode: 'path',\\n  highlightLocations: [\\n    {\\n      anchor: {\\n        path: [0, 0],\\n        offset: 5,\\n      },\\n      focus: {\\n        path: [3, 2, 0],\\n        offset: 2,\\n      },\\n    },\\n    [1, 0],\\n    [5],\\n  ],\\n}\\n\\nexport const NodeSpecPoint = Template.bind({})\\nNodeSpecPoint.args = {\\n  mode: 'point',\\n}\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"NodeSpecPath\":{\"startLoc\":{\"col\":39,\"line\":25},\"endLoc\":{\"col\":71,\"line\":25},\"startBody\":{\"col\":39,\"line\":25},\"endBody\":{\"col\":71,\"line\":25}},\"NodeSpecPoint\":{\"startLoc\":{\"col\":39,\"line\":25},\"endLoc\":{\"col\":71,\"line\":25},\"startBody\":{\"col\":39,\"line\":25},\"endBody\":{\"col\":71,\"line\":25}}};\n    \nimport React from 'react'\nimport { Story, Meta } from '@storybook/react'\nimport { NodeSpec, NodeSpecProps } from '../../components'\nimport { SlateContextDecorator } from '../util'\nimport { mockParagraphsAndList } from '../util/mockData'\n\nexport default {\n  title: 'Storybook/Components/NodeSpec',\n  component: NodeSpec,\n  decorators: [\n    (Story, context) => {\n      return (\n        <SlateContextDecorator\n          story={Story}\n          initialSlateValue={context.parameters.initialSlateValue}\n        />\n      )\n    },\n  ],\n  parameters: {\n    initialSlateValue: mockParagraphsAndList,\n  },\n} as Meta\n\nconst Template: Story<NodeSpecProps> = (args) => <NodeSpec {...args} />\n\nexport const NodeSpecPath = Template.bind({});\nNodeSpecPath.args = {\n  mode: 'path',\n  highlightLocations: [\n    {\n      anchor: {\n        path: [0, 0],\n        offset: 5,\n      },\n      focus: {\n        path: [3, 2, 0],\n        offset: 2,\n      },\n    },\n    [1, 0],\n    [5],\n  ],\n}\n\nexport const NodeSpecPoint = Template.bind({});NodeSpecPoint.args = {\n  mode: 'point',\n}\n\n\n\nNodeSpecPath.parameters = { storySource: { source: \"(args) => <NodeSpec {...args} />\" }, ...NodeSpecPath.parameters };\nNodeSpecPoint.parameters = { storySource: { source: \"(args) => <NodeSpec {...args} />\" }, ...NodeSpecPoint.parameters };",
  "/stories/components/NodeTree.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story, Meta } from '@storybook/react'\\nimport { NodeTree, NodeTreeProps } from '../../components'\\nimport { mockParagraphsAndList } from '../util/mockData'\\nimport { NodeSpecContextDecorator } from '../util'\\nimport { useSlate } from 'slate-react'\\n\\nexport default {\\n  title: 'Storybook/Components/NodeTree',\\n  component: NodeTree,\\n  decorators: [\\n    (Story, context) => {\\n      return (\\n        <NodeSpecContextDecorator\\n          story={Story}\\n          initialSlateValue={context.parameters.initialSlateValue}\\n          initialHighlightLocations={[\\n            {\\n              anchor: {\\n                path: [0, 0],\\n                offset: 5,\\n              },\\n              focus: {\\n                path: [3, 2, 0],\\n                offset: 2,\\n              },\\n            },\\n            [1, 0],\\n            [5],\\n          ]}\\n        />\\n      )\\n    },\\n  ],\\n  parameters: {\\n    initialSlateValue: mockParagraphsAndList,\\n  },\\n} as Meta\\n\\nconst Template: Story<NodeTreeProps> = (args) => {\\n  const editor = useSlate()\\n  return <NodeTree {...args} node={editor} />\\n}\\n\\nexport const NodeTreeDefault = Template.bind({})\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"NodeTreeDefault\":{\"startLoc\":{\"col\":39,\"line\":40},\"endLoc\":{\"col\":1,\"line\":43},\"startBody\":{\"col\":39,\"line\":40},\"endBody\":{\"col\":1,\"line\":43}}};\n    \nimport React from 'react'\nimport { Story, Meta } from '@storybook/react'\nimport { NodeTree, NodeTreeProps } from '../../components'\nimport { mockParagraphsAndList } from '../util/mockData'\nimport { NodeSpecContextDecorator } from '../util'\nimport { useSlate } from 'slate-react'\n\nexport default {\n  title: 'Storybook/Components/NodeTree',\n  component: NodeTree,\n  decorators: [\n    (Story, context) => {\n      return (\n        <NodeSpecContextDecorator\n          story={Story}\n          initialSlateValue={context.parameters.initialSlateValue}\n          initialHighlightLocations={[\n            {\n              anchor: {\n                path: [0, 0],\n                offset: 5,\n              },\n              focus: {\n                path: [3, 2, 0],\n                offset: 2,\n              },\n            },\n            [1, 0],\n            [5],\n          ]}\n        />\n      )\n    },\n  ],\n  parameters: {\n    initialSlateValue: mockParagraphsAndList,\n  },\n} as Meta\n\nconst Template: Story<NodeTreeProps> = (args) => {\n  const editor = useSlate()\n  return <NodeTree {...args} node={editor} />\n}\n\nexport const NodeTreeDefault = Template.bind({});\n\n\nNodeTreeDefault.parameters = { storySource: { source: \"(args) => {\\n  const editor = useSlate()\\n  return <NodeTree {...args} node={editor} />\\n}\" }, ...NodeTreeDefault.parameters };",
  "/stories/Interfaces/Interface.stories.tsx": "\n      /* eslint-disable */\n      // @ts-nocheck\n      // @ts-ignore\n      var __STORY__ = \"import React from 'react'\\nimport { Story } from '@storybook/react'\\nimport { ApiView, ApiViewProps } from '../../components'\\nimport {\\n  editorApiFunctions,\\n  nodeApiFunctions,\\n  pathApiFunctions,\\n} from '../util/api'\\nimport { createStoryFactory, createStoryMeta } from './util'\\n\\nconst meta = createStoryMeta()\\nexport default meta\\n\\nconst InterfaceTemplate: Story<ApiViewProps> = (args) => <ApiView {...args} />\\n\\nconst createEditorStory = createStoryFactory(\\n  () => InterfaceTemplate.bind({}),\\n  'Editor',\\n  editorApiFunctions\\n)\\n\\nconst createPathStory = createStoryFactory(\\n  () => InterfaceTemplate.bind({}),\\n  'Path',\\n  pathApiFunctions\\n)\\n\\nconst createNodeStory = createStoryFactory(\\n  () => InterfaceTemplate.bind({}),\\n  'Node',\\n  nodeApiFunctions\\n)\\n\\nexport const editor = createEditorStory()\\nexport const node = createNodeStory()\\nexport const path = createPathStory()\\n\";\n      // @ts-ignore\n      var __LOCATIONS_MAP__ = {\"editor\":{\"startLoc\":{\"col\":22,\"line\":34},\"endLoc\":{\"col\":41,\"line\":34},\"startBody\":{\"col\":22,\"line\":34},\"endBody\":{\"col\":41,\"line\":34}},\"node\":{\"startLoc\":{\"col\":20,\"line\":35},\"endLoc\":{\"col\":37,\"line\":35},\"startBody\":{\"col\":20,\"line\":35},\"endBody\":{\"col\":37,\"line\":35}},\"path\":{\"startLoc\":{\"col\":20,\"line\":36},\"endLoc\":{\"col\":37,\"line\":36},\"startBody\":{\"col\":20,\"line\":36},\"endBody\":{\"col\":37,\"line\":36}}};\n    \nimport React from 'react'\nimport { Story } from '@storybook/react'\nimport { ApiView, ApiViewProps } from '../../components'\nimport {\n  editorApiFunctions,\n  nodeApiFunctions,\n  pathApiFunctions,\n} from '../util/api'\nimport { createStoryFactory, createStoryMeta } from './util'\n\nconst meta = createStoryMeta()\nexport default meta\n\nconst InterfaceTemplate: Story<ApiViewProps> = (args) => <ApiView {...args} />\n\nconst createEditorStory = createStoryFactory(\n  () => InterfaceTemplate.bind({}),\n  'Editor',\n  editorApiFunctions\n)\n\nconst createPathStory = createStoryFactory(\n  () => InterfaceTemplate.bind({}),\n  'Path',\n  pathApiFunctions\n)\n\nconst createNodeStory = createStoryFactory(\n  () => InterfaceTemplate.bind({}),\n  'Node',\n  nodeApiFunctions\n)\n\nexport const editor = createEditorStory();\nexport const node = createNodeStory();\nexport const path = createPathStory();\n\n\neditor.parameters = { storySource: { source: \"createEditorStory()\" }, ...editor.parameters };\nnode.parameters = { storySource: { source: \"createNodeStory()\" }, ...node.parameters };\npath.parameters = { storySource: { source: \"createPathStory()\" }, ...path.parameters };",
  "/theme.ts": "import { css } from '@emotion/core'\nimport { create, themes } from '@storybook/theming'\n\nconst color = {\n  node: {\n    backgroundColor: '#1E1E1E',\n    element: '#569CD6',\n    text: '#4EC9B0',\n    stringColor: '#CE9178',\n  },\n} as const\n\nconst theme = {\n  ...create(themes.normal),\n  color,\n  placeholderColor: '#757575',\n  code: {\n    commentColor: '#6A9955',\n    paramColor: '#569CD6',\n    argColor: '#9CDCFE',\n    backgroundColor: '#1E1E1E',\n    separatorColor: '#D4D4D4',\n    typeColor: '#4EC9B0',\n    functionNameColor: '#DCDCAA',\n  },\n} as const\n\nexport default theme\n\nexport type Theme = typeof theme\n\nexport const globalStyles = css`\n  body {\n    font-family: 'Open Sans';\n    font-size: 16px;\n  }\n  * {\n    box-sizing: border-box;\n  }\n  input,\n  select {\n    font-size: 1em; // stop zoom on IOS\n  }\n`\n",
  "/stories/util/mockData.ts": "import { Node } from 'slate'\n\nexport const emptySlateValue = (): Node[] => {\n  return [\n    {\n      children: [{ text: '' }],\n    },\n  ]\n}\n\nexport const mockParagraphsAndList = (): Node[] => [\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text:\n          'This is generic content showcasing various Slate data model features. Text formatting such as ',\n      },\n      {\n        bold: true,\n        text: 'bold',\n      },\n      {\n        text: ' and ',\n      },\n      {\n        italic: true,\n        text: 'italics',\n      },\n      {\n        text: 'are implemented as \"marks\" on Text nodes.',\n      },\n    ],\n  },\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text:\n          'Differing block types such as lists and paragraphs are defined by attributes on Element nodes.',\n      },\n    ],\n  },\n  {\n    type: 'paragraph',\n    children: [{ text: 'Ccc ccc ccc.' }],\n  },\n  {\n    type: 'unordered-list',\n    children: [\n      { type: 'list-item', children: [{ text: 'One' }] },\n      { type: 'list-item', children: [{ text: 'Two' }] },\n      { type: 'list-item', children: [{ text: 'Three' }] },\n    ],\n  },\n  {\n    type: 'paragraph',\n    children: [{ text: 'Ddd ddd ddd.' }],\n  },\n  {\n    type: 'paragraph',\n    children: [{ text: 'Eee eee eee.' }],\n  },\n]\n",
  "/stories/util/api.ts": "import { Editor, Element, Node, NodeEntry, Path, Text } from 'slate'\nimport {\n  ApiFunction,\n  Arg,\n  EditorArg,\n  ObjectArg,\n} from '../../components/ApiControls/model'\nimport { not } from '../../util/callbacks'\n\nimport editorJson from '../specs/editor.json'\nimport nodeJson from '../specs/node.json'\nimport pathJson from '../specs/path.json'\n\ninterface ApiRaw {\n  name: string\n  methods: MethodRaw[]\n}\n\ninterface MethodRaw {\n  name: string\n  args: ArgRaw[]\n  documentation: string[]\n  returnValue: {\n    type: string\n    comment?: string\n    yieldsComment?: string\n  }\n  typeParameters: string[]\n}\n\ntype ArgRaw =\n  | {\n      isOptional: boolean\n      name: string\n      type: string\n      comment?: string\n    }\n  | {\n      isOptional: boolean\n      name: string\n      args: ArgRaw[]\n      comment?: string\n    }\n\nconst typeMap: Record<string, Arg['argType']> = {\n  Editor: 'editor',\n  Location: 'path',\n  Path: 'path',\n  Point: 'point',\n  'Range | Path | Point': 'path',\n  'Range | Path | Point | Span': 'path',\n  'NodeMatch<T>': 'function',\n  '((node: Node) => boolean) | ((node: Node) => node is T)': 'function',\n  '((node: Node) => boolean) | ((node: Node) => node is T_1)': 'function',\n  '((node: Node) => boolean) | ((node: Node) => node is T_2)': 'function',\n  '((node: Node) => boolean) | ((node: Node) => node is T_3)': 'function',\n  '((node: Node) => boolean) | ((node: Node) => node is T_4)': 'function',\n  '(entry: NodeEntry<Node>) => boolean': 'function',\n  '(node: NodeEntry<Node>) => boolean': 'function',\n  Element: 'node',\n  Node: 'node',\n  boolean: 'boolean',\n  number: 'number',\n  string: 'string',\n  any: 'string',\n}\n\nconst nodePredicateOptions = [\n  ['Editor.isEditor', Editor.isEditor],\n  ['Element.isElement', Element.isElement],\n  ['Text.isText', Text.isText],\n  ['not(Editor.isEditor)', not(Editor.isEditor)],\n  ['not(Element.isElement)', not(Element.isElement)],\n  ['not(Text.isText)', not(Text.isText)],\n] as [string, Function][]\n\nconst entryPredicateOptions = [\n  [\n    '([node]) => Editor.isEditor(node)',\n    ([node]: NodeEntry<Node>) => Editor.isEditor(node),\n  ],\n  [\n    '([node]) => Element.isElement(node)',\n    ([node]: NodeEntry<Node>) => Element.isElement(node),\n  ],\n  [\n    '([node]) => Text.isText(node)',\n    ([node]: NodeEntry<Node>) => Text.isText(node),\n  ],\n  [\n    '([node]) => not(Editor.isEditor)(node)',\n    ([node]: NodeEntry<Node>) => not(Editor.isEditor)(node),\n  ],\n  [\n    '([node]) => not(Element.isElement)(node)',\n    ([node]: NodeEntry<Node>) => not(Element.isElement)(node),\n  ],\n  [\n    '([node]) => not(Text.isText)(node)',\n    ([node]: NodeEntry<Node>) => not(Text.isText)(node),\n  ],\n] as [string, Function][]\n\nfunction isEntryPredicateType(type: string) {\n  return [\n    '(entry: NodeEntry<Node>) => boolean',\n    '(node: NodeEntry<Node>) => boolean',\n  ].includes(type)\n}\n\nexport function loadEditorApi(): Record<keyof typeof Editor, ApiFunction> {\n  return parseApi(Editor, editorJson as ApiRaw)\n}\n\nexport function loadNodeApi(): Record<keyof typeof Node, ApiFunction> {\n  return parseApi(Node, nodeJson as ApiRaw)\n}\n\nexport function loadPathApi(): Record<keyof typeof Path, ApiFunction> {\n  return parseApi(Path, pathJson as ApiRaw)\n}\n\nfunction parseApi<TApi>(api: TApi, json: ApiRaw): Record<string, ApiFunction> {\n  const result: Record<string, ApiFunction> = {}\n\n  for (const method of json.methods) {\n    try {\n      const args: (EditorArg | Arg | ObjectArg)[] = []\n\n      for (const argRaw of method.args) {\n        args.push(parseArg(argRaw))\n      }\n\n      result[method.name] = {\n        fn: (api[method.name as keyof TApi] as unknown) as Function,\n        name: method.name,\n        description: method.documentation,\n        generics: method.typeParameters\n          ? `<${method.typeParameters.join(', ')}>`\n          : undefined,\n        isGenerator: method.returnValue.type.startsWith('Generator<'),\n        returnValue: {\n          type: method.returnValue.type,\n          comment: method.returnValue.comment ?? '',\n          yieldsComment: method.returnValue.yieldsComment ?? '',\n        },\n        args,\n      }\n    } catch (err) {\n      console.log(method.name, ':', String(err).replace('Error: ', ''))\n    }\n  }\n\n  return result\n}\n\n/**\n * Parse raw arg to an arg\n */\nfunction parseArg(argRaw: ArgRaw): EditorArg | Arg | ObjectArg {\n  let arg: EditorArg | Arg | ObjectArg\n\n  if ('args' in argRaw) {\n    arg = {\n      name: argRaw.name,\n      argType: 'object',\n      isOptional: argRaw.isOptional,\n      args: argRaw.args.map(parseArg) as Arg[],\n    }\n  } else {\n    let argType = typeMap[argRaw.type]\n\n    if (argType == null && argRaw.type.match(/\" | \"/)) {\n      argType = 'stringLiteral'\n    }\n\n    if (argType == null) {\n      throw new Error(`Unmapped '${argRaw.type}'`)\n    }\n\n    const options = (argType === 'function'\n      ? isEntryPredicateType(argRaw.type)\n        ? entryPredicateOptions\n        : nodePredicateOptions\n      : argType === 'boolean'\n      ? [true, false]\n      : argType === 'stringLiteral'\n      ? argRaw.type.replace(/[ \"]/g, '').split('|')\n      : []) as any\n\n    arg = {\n      name: argRaw.name,\n      comment: argRaw.comment?.split('\\r\\n') ?? '',\n      type: argRaw.type,\n      argType,\n      isOptional: argRaw.isOptional,\n      options,\n    }\n  }\n\n  return arg\n}\n\nexport const editorApiFunctions = loadEditorApi()\nexport const nodeApiFunctions = loadNodeApi()\nexport const pathApiFunctions = loadPathApi()\n",
  "/stories/Interfaces/util.tsx": "import React from 'react'\nimport { Meta, Story } from '@storybook/react'\nimport { Node } from 'slate'\nimport { renderElement, renderLeaf } from './render'\nimport { ApiFunction } from '../../components/ApiControls/model'\nimport { ApiViewProps } from '../../components'\nimport { NodeSpecContextDecorator } from '../util'\n\nexport function createStoryMeta(interfaceName?: string) {\n  return {\n    title: interfaceName\n      ? `Slate/Interfaces/${interfaceName}`\n      : 'Slate/Interfaces',\n    decorators: [\n      (Story, context) => {\n        const [value, setValue] = React.useState<Node[]>(\n          context.parameters.initialSlateValue\n        )\n        return (\n          <NodeSpecContextDecorator\n            story={Story}\n            initialSlateValue={value}\n            onChange={(value) => {\n              setValue(value)\n            }}\n          />\n        )\n      },\n    ],\n  } as Meta\n}\n\nexport function createStoryFactory<\n  TApi extends Record<string, ApiFunction>,\n  K extends keyof TApi\n>(storyFn: () => Story<ApiViewProps>, label: string, apiFunctions: TApi) {\n  return function createStory(fnName?: K) {\n    const story = storyFn()\n    story.storyName = (fnName as string) ?? label\n    const title = fnName ? `${label}.${fnName}` : label\n    if (!fnName) {\n      fnName = Object.keys(apiFunctions)[0] as K\n    }\n    const initialApiFunction = apiFunctions[fnName]!\n    story.args = {\n      title,\n      renderElement,\n      renderLeaf,\n      initialApiFunction,\n      apiFunctions,\n    }\n    story.parameters = {\n      initialSlateValue,\n      actions: {\n        disable: true,\n      },\n      controls: {\n        disable: true,\n      },\n      previewTabs: {\n        'storybook/docs/panel': {\n          hidden: true,\n        },\n        'sourceCodeAddon/panel': {\n          hidden: true,\n        },\n      },\n    }\n\n    return story\n  }\n}\n\nexport function initialSlateValue() {\n  return [\n    {\n      type: 'paragraph',\n      children: [\n        {\n          text:\n            \"This sandbox is designed to allow interaction with some of Slate's APIs. There are 4 primary panels. The Editor instance tied to this Editable will be passed to any API methods that accept and Editor argument.\",\n        },\n      ],\n    },\n    {\n      type: 'ordered-list',\n      children: [\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Editor',\n              bold: true,\n            },\n            {\n              text:\n                ' - by default this contains the instructions you are currently reading, but you can modify the content as well.',\n            },\n          ],\n        },\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'API',\n              bold: true,\n            },\n            {\n              text:\n                ' - this panel contains controls to provide values to API methods. The result of the method call will be shown in the Results panel and in some cases will be applied to the Data Model panel.',\n            },\n          ],\n        },\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Results',\n              bold: true,\n            },\n            {\n              text: ' - contains the results of the last API run.',\n            },\n          ],\n        },\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Data Model',\n              bold: true,\n            },\n            {\n              text:\n                ' - this panel shows the paths + nodes in the data model for the current editor. The current selection is represented by a green and red vertical pipe representing the anchor and focus points respectively (try changing the content or the selection to see how it impacts the nodes).',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      type: 'paragraph',\n      children: [\n        {\n          text: 'To test an API method:',\n        },\n      ],\n    },\n    {\n      type: 'ordered-list',\n      children: [\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Set api parameters.',\n            },\n          ],\n        },\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Optionally select text in the Editor.',\n            },\n          ],\n        },\n        {\n          type: 'list-item',\n          children: [\n            {\n              text: 'Click \"run\" to see the results of the API call.',\n            },\n          ],\n        },\n      ],\n    },\n  ]\n}\n",
  "/components/ApiControls/model.ts": "import React from 'react'\nimport { Editor, Node, Path, Point } from 'slate'\nimport { useSlate } from 'slate-react'\n\nexport interface ArgBase {\n  name: string\n  isOptional?: boolean\n  type: string\n  comment: string | string[]\n}\n\nexport interface EditorArg extends ArgBase {\n  argType: 'editor'\n}\n\nexport interface PathArg extends ArgBase {\n  argType: 'path'\n}\n\nexport interface PointArg extends ArgBase {\n  argType: 'point'\n}\n\nexport interface NodeArg extends ArgBase {\n  argType: 'node'\n}\n\nexport interface NumberArg extends ArgBase {\n  argType: 'number'\n}\n\nexport interface StringArg extends ArgBase {\n  argType: 'string'\n}\n\nexport interface StringLiteralArg extends ArgBase {\n  argType: 'stringLiteral'\n  options: string[]\n}\n\nexport interface BooleanArg extends ArgBase {\n  argType: 'boolean'\n  options: boolean[]\n}\n\nexport interface FunctionArg extends ArgBase {\n  argType: 'function'\n  options: [string, Function][]\n}\n\nexport type ObjectArg = {\n  argType: 'object'\n  name: string\n  isOptional: boolean\n  args: Arg[]\n}\n\nexport type Arg =\n  | NumberArg\n  | PathArg\n  | PointArg\n  | NodeArg\n  | StringArg\n  | StringLiteralArg\n  | BooleanArg\n  | FunctionArg\n  | EditorArg\n\nexport type ArgValue<TArg extends Arg> = {\n  editor: Editor\n  number: number\n  string: string\n  path: Path\n  point: Point\n  node: Node\n  stringLiteral: string\n  boolean: boolean\n  function: [string, Function]\n}[TArg['argType']]\n\n// export type ArgValue = string | boolean | Function | Path | undefined\nexport type ObjectArgValues = Record<string, ArgValue<Arg>>\n\nexport interface ApiFunction {\n  fn: Function\n  name: string\n  description: string | string[]\n  generics?: React.ReactNode\n  isGenerator?: boolean\n  args: (EditorArg | Arg | ObjectArg)[]\n  returnValue: {\n    type: React.ReactNode\n    comment: string\n    yieldsComment: string\n  }\n}\n\nexport function useArgValues(args: (EditorArg | Arg | ObjectArg)[]) {\n  const editor = useSlate()\n\n  const initValues = React.useCallback(\n    (args: (EditorArg | Arg | ObjectArg)[]) => {\n      return args.map((arg) => {\n        if (arg.argType === 'editor') {\n          return editor\n        }\n\n        if (arg.argType === 'object') {\n          return {}\n        }\n\n        return undefined\n      })\n    },\n    [editor]\n  )\n\n  const [values, setValues] = React.useState<\n    (ArgValue<Arg> | ObjectArgValues | undefined)[]\n  >(() => {\n    return initValues(args)\n  })\n\n  const resetValues = React.useCallback(\n    (args: (EditorArg | Arg | ObjectArg)[]) => {\n      setValues(initValues(args))\n    },\n    [initValues]\n  )\n\n  return { values, setValues, resetValues } as const\n}\n\nexport function isNumberArg(arg: Arg): arg is NumberArg {\n  return arg.argType === 'number'\n}\n\nexport function isStringArg(arg: Arg): arg is StringArg {\n  return arg.argType === 'string'\n}\n\nexport function isStringLiteralArg(arg: Arg): arg is StringLiteralArg {\n  return arg.argType === 'stringLiteral'\n}\n\nexport function isBooleanArg(arg: Arg): arg is BooleanArg {\n  return arg.argType === 'boolean'\n}\n\nexport function isFunctionArg(arg: Arg): arg is FunctionArg {\n  return arg.argType === 'function'\n}\n\nexport function isPathArg(arg: Arg): arg is PathArg {\n  return arg.argType === 'path'\n}\n\nexport function isPointArg(arg: Arg): arg is PointArg {\n  return arg.argType === 'point'\n}\n\nexport function isNodeArg(arg: Arg): arg is NodeArg {\n  return arg.argType === 'node'\n}\n\nexport function isObjectArg(arg: Arg | ObjectArg): arg is ObjectArg {\n  return arg.argType === 'object'\n}\n",
  "/components/index.ts": "export { App } from './App'\nexport { Editor } from './Editor'\n\nexport * from './NodeSpec'\n\nexport { default as ApiControls } from './ApiControls/ApiControls'\nexport type { ApiControlsProps } from './ApiControls/ApiControls'\n\nexport { default as ArgLabel } from './ApiControls/ArgLabel'\nexport type { ArgLabelProps } from './ApiControls/ArgLabel'\n\nexport { default as ApiResult } from './ApiResult/ApiResult'\nexport type { ApiResultProps } from './ApiResult/ApiResult'\n\nexport { default as ApiView } from './ApiView/ApiView'\nexport type { ApiViewProps } from './ApiView/ApiView'\n\nexport { default as Modal } from './Modal/Modal'\nexport type { ModalProps } from './Modal/Modal'\n\nexport { default as NodeSelector } from './NodeSelector/NodeSelector'\nexport type { NodeSelectorProps } from './NodeSelector/NodeSelector'\n\nexport { default as NodeTree } from './NodeTree/NodeTree'\nexport type { NodeTreeProps } from './NodeTree/NodeTree'\n\nexport { default as EditorNode } from './NodeTree/EditorNode'\nexport type { EditorNodeProps } from './NodeTree/EditorNode'\n\nexport { default as ElementNode } from './NodeTree/ElementNode'\nexport type { ElementNodeProps } from './NodeTree/ElementNode'\n\nexport { default as TextNode } from './NodeTree/TextNode'\nexport type { TextNodeProps } from './NodeTree/TextNode'\n\nexport { default as TextNodeContent } from './NodeTree/TextNodeContent'\nexport type { TextNodeContentProps } from './NodeTree/TextNodeContent'\n\nexport { default as NodeProps } from './NodeTree/NodeProps'\nexport type { NodePropsProps } from './NodeTree/NodeProps'\n\nexport { default as PathView } from './PathView/PathView'\nexport type { PathViewProps } from './PathView/PathView'\n\nexport { default as Selector } from './Selector/Selector'\nexport type { SelectorProps } from './Selector/Selector'\n",
  "/stories/util/index.ts": "export { default as SlateContext } from './SlateContext'\nexport type { SlateContextProps } from './SlateContext'\n\nexport * from './StoryContextDecorator'\n",
  "/util/callbacks.ts": "/** Negate a predicate */\nexport function not<TValue>(predicate: (value: TValue) => boolean) {\n  return (value: TValue): boolean => {\n    return !predicate(value)\n  }\n}\n",
  "/stories/Interfaces/render.tsx": "import React from 'react'\nimport { RenderElementProps, RenderLeafProps } from 'slate-react'\n\nexport function renderElement({\n  element,\n  attributes,\n  children,\n}: RenderElementProps) {\n  let E = 'p'\n\n  switch (element.type) {\n    case 'unordered-list':\n      E = 'ul'\n      break\n\n    case 'ordered-list':\n      E = 'ol'\n      break\n\n    case 'list-item':\n      E = 'li'\n      break\n  }\n\n  return <E {...attributes}>{children}</E>\n}\n\nexport function renderLeaf({ leaf, attributes, children }: RenderLeafProps) {\n  if (leaf.bold) {\n    children = <strong>{children}</strong>\n  }\n  if (leaf.italic) {\n    children = <em>{children}</em>\n  }\n  return <span {...attributes}>{children}</span>\n}\n",
  "/stories/util/SlateContext.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { createEditor, Node } from 'slate'\nimport { Slate, withReact } from 'slate-react'\n\nconst componentCss = css`\n  [contenteditable='true'] {\n    border: 1px solid #ccc;\n    padding: 4px;\n  }\n`\n\nexport interface SlateContextProps {\n  initialValue: Node[] | (() => Node[])\n  onChange?: (value: Node[]) => void\n}\n\nconst SlateContext: React.FC<SlateContextProps> = ({\n  initialValue,\n  children,\n  onChange,\n}) => {\n  const editor = React.useMemo(() => withReact(createEditor()), [])\n  const [value, setValue] = React.useState<Node[]>(initialValue)\n\n  const onChangeInternal = React.useCallback(\n    (value: Node[]) => {\n      setValue(value)\n      onChange?.(value)\n    },\n    [onChange]\n  )\n\n  return (\n    <div css={componentCss}>\n      <Slate editor={editor} value={value} onChange={onChangeInternal}>\n        {children}\n      </Slate>\n    </div>\n  )\n}\n\nexport default SlateContext\n",
  "/stories/util/StoryContextDecorator.tsx": "import React from 'react'\nimport { Story } from '@storybook/react'\nimport { Location, Node } from 'slate'\nimport { SlateContext } from '../util'\nimport { NodeSpecContextProvider } from '../../components'\nimport { emptySlateValue } from './mockData'\n\nexport interface StoryDecoratorProps {\n  story: Story\n  initialSlateValue?: Node[] | (() => Node[])\n  onChange?: (value: Node[]) => void\n}\n\nexport const SlateContextDecorator: React.FC<StoryDecoratorProps> = ({\n  story: Story,\n  initialSlateValue,\n  onChange,\n}) => {\n  return (\n    <SlateContext\n      initialValue={initialSlateValue ?? emptySlateValue}\n      onChange={onChange}\n    >\n      <Story />\n    </SlateContext>\n  )\n}\n\nexport const NodeSpecContextDecorator: React.FC<\n  StoryDecoratorProps & { initialHighlightLocations?: Location[] }\n> = ({\n  story: Story,\n  initialSlateValue,\n  onChange,\n  initialHighlightLocations = [],\n}) => {\n  const [highlightLocations, setHighlightLocations] = React.useState<\n    Location[]\n  >(initialHighlightLocations)\n\n  return (\n    <SlateContext\n      initialValue={initialSlateValue ?? emptySlateValue}\n      onChange={onChange}\n    >\n      <NodeSpecContextProvider\n        value={{ highlightLocations, setHighlightLocations }}\n      >\n        <Story />\n      </NodeSpecContextProvider>\n    </SlateContext>\n  )\n}\n",
  "/components/NodeTree/NodeProps.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Node, Text } from 'slate'\n\nconst componentCss = css``\n\nexport interface NodePropsProps {\n  className?: string\n  node: Node\n}\n\nconst NodeProps: React.FC<NodePropsProps> = ({ className, node }) => {\n  const props = Text.isText(node)\n    ? Object.keys(node).filter((prop) => prop !== 'text')\n    : Object.keys(node).filter((prop) => prop !== 'children' && Text)\n  return (\n    <span css={componentCss} className={className}>\n      {props.map((p) => (\n        <span key={p}>\n          {p}={JSON.stringify(node[p])}\n        </span>\n      ))}\n    </span>\n  )\n}\n\nexport default NodeProps\n",
  "/components/PathView/PathView.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Path } from 'slate'\n\nconst componentCss = css``\n\nexport interface PathViewProps {\n  className?: string\n  path: Path\n}\n\nconst PathView: React.FC<PathViewProps> = ({ className, path }) => {\n  return (\n    <span css={componentCss} className={className}>\n      {JSON.stringify(path)}\n    </span>\n  )\n}\n\nexport default PathView\n",
  "/components/Selector/Selector.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\n\nconst componentCss = css``\n\nexport interface SelectorProps<\n  TValue extends string | boolean | [string, Function]\n> {\n  label: string\n  options: TValue[]\n  value?: TValue\n  onChange: (value?: TValue) => void\n}\n\nconst Selector = <TValue extends string | boolean | [string, Function]>({\n  label,\n  options,\n  value,\n  onChange,\n}: SelectorProps<TValue>) => {\n  const [In, Out] = React.useMemo(() => {\n    if (typeof options[0] === 'boolean') {\n      return [String, (str?: string) => str === 'true'] as const\n    }\n\n    if (isTuple(options)) {\n      return [\n        (option?: [string, Function]) => option?.[0],\n        (str: string) =>\n          options.find(([label]: [string, Function]) => label === str),\n      ] as const\n    }\n\n    return [String, String] as const\n  }, [options])\n\n  const onChangeInternal = React.useCallback(\n    ({ currentTarget }: React.ChangeEvent<HTMLSelectElement>) => {\n      onChange(\n        currentTarget.selectedIndex\n          ? (Out(currentTarget.value) as TValue)\n          : undefined\n      )\n    },\n    [onChange, Out]\n  )\n\n  return (\n    <select\n      css={componentCss}\n      className={value === undefined ? 'is-empty' : undefined}\n      onChange={onChangeInternal}\n      value={In(value as Parameters<typeof In>[0])}\n    >\n      <option value=\"\">- {label} -</option>\n      {options.map((option) => {\n        const optionStr = In(option as Parameters<typeof In>[0])\n        return (\n          <option key={optionStr} value={optionStr}>\n            {optionStr}\n          </option>\n        )\n      })}\n    </select>\n  )\n}\n\nexport default Selector\n\nfunction isTuple(value: unknown[]): value is [string, Function][] {\n  return Array.isArray(value[0]) && value[0].length === 2\n}\n",
  "/components/NodeTree/TextNode.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Path, Text } from 'slate'\nimport { NodeProps, PathView } from '..'\nimport { Theme } from '../../theme'\n\nconst componentCss = ({ color: { node } }: Theme) => css`\n  display: flex;\n  i {\n    color: ${node.text};\n  }\n  > * {\n    margin-right: 0.3em;\n  }\n`\n\nconst propsCss = ({ textInverseColor }: Theme) => css`\n  color: ${textInverseColor};\n`\n\nexport interface TextNodeProps {\n  className?: string\n  node: Text\n  path: Path\n}\n\nconst TextNode: React.FC<TextNodeProps> = ({ className, node, path }) => {\n  return (\n    <div title=\"Text Node\" css={componentCss} className={className}>\n      <i className=\"mdi mdi-alpha-t-circle-outline\"></i>\n      <PathView\n        css={({ color: { node } }: Theme) =>\n          css`\n            color: ${node.text};\n          `\n        }\n        path={path}\n      />\n      <NodeProps css={propsCss} node={node} />\n    </div>\n  )\n}\n\nexport default TextNode\n",
  "/components/NodeTree/TextNodeContent.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Node, NodeEntry, Path, Point, Text } from 'slate'\nimport { useNodeSpecContext } from '..'\nimport { Theme } from '../../theme'\n\nconst componentCss = css`\n  .anchor,\n  .focus,\n  .point {\n    border-right: 2px solid;\n    position: absolute;\n    height: 1.2em;\n  }\n  .anchor {\n    border-color: green;\n    background-color: green;\n  }\n  .focus {\n    border-color: red;\n    background-color: red;\n  }\n  .point {\n    border-color: blue;\n    background-color: blue;\n  }\n`\n\nexport interface TextNodeContentProps {\n  node: Text\n  path: Path\n}\n\nconst TextNodeContent: React.FC<TextNodeContentProps> = ({ node, path }) => {\n  const { labeledPoints } = useNodeSpecContext()\n  const tokens = nodeTokens([node, path], labeledPoints)\n\n  return (\n    <span\n      css={componentCss}\n      // css={\n      //   mode === 'point' &&\n      //   css`\n      //     :hover {\n      //       background-color: #1fa8fd;\n      //     }\n      //   `\n      // }\n      className=\"text-node-content\"\n    >\n      {tokens.map((token, i) =>\n        typeof token === 'string' ? (\n          <span\n            // css={\n            //   mode === 'point' &&\n            //   css`\n            //     cursor: text;\n            //   `\n            // }\n            className=\"text-token\"\n            key={i}\n          >\n            {token}\n          </span>\n        ) : (\n          <span\n            title={token.label}\n            css={(theme: Theme) => css`\n              position: relative;\n              span {\n                background-color: inherit;\n                color: ${theme.textInverseColor};\n                position: absolute;\n                top: -8px;\n                font-size: 10px;\n                padding: 0 4px;\n              }\n            `}\n            key={i}\n            className={token.label}\n          >\n            <span>{token.label.substr(0, 1)}</span>\n          </span>\n        )\n      )}\n    </span>\n  )\n}\n\nexport default TextNodeContent\n\nfunction nodeTokens(\n  [node, path]: NodeEntry<Node>,\n  points: { label: string; point: Point }[]\n): (string | { label: string })[] {\n  const nodeText = Node.string(node)\n  const tokens: (string | { label: string })[] = []\n\n  // filter down to only points in current path\n  const pointsInPath = points.filter(({ point }) =>\n    Path.equals(point.path, path)\n  )\n\n  let i = 0\n\n  // tokenize text using any points that apply\n  for (const { label, point } of pointsInPath) {\n    const { offset } = point\n\n    if (offset > i) {\n      tokens.push(nodeText.substr(i, offset - i))\n      i = offset\n    }\n\n    tokens.push({\n      label,\n    })\n  }\n\n  if (i < nodeText.length) {\n    tokens.push(nodeText.substr(i))\n  }\n\n  return tokens\n}\n",
  "/components/NodeTree/ElementNode.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Element, Path } from 'slate'\nimport { NodeProps, PathView } from '..'\nimport { Theme } from '../../theme'\n\nconst componentCss = ({ color: { node } }: Theme) => css`\n  color: ${node.element};\n  display: flex;\n  > * {\n    margin-right: 0.3em;\n  }\n`\n\nconst propsCss = ({ textInverseColor }: Theme) => css`\n  color: ${textInverseColor};\n`\n\nexport interface ElementNodeProps {\n  className?: string\n  node: Element\n  path: Path\n}\n\nconst ElementNode: React.FC<ElementNodeProps> = ({ className, node, path }) => {\n  return (\n    <div title=\"Element Node\" css={componentCss} className={className}>\n      <i className=\"mdi mdi-alpha-e-circle-outline\"></i>\n      <PathView path={path} />\n      <NodeProps css={propsCss} node={node} />\n    </div>\n  )\n}\n\nexport default ElementNode\n",
  "/components/NodeTree/EditorNode.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Editor, Path } from 'slate'\nimport { PathView } from '..'\n\nconst componentCss = css`\n  display: flex;\n  > * {\n    margin-right: 0.3em;\n  }\n`\n\nexport interface EditorNodeProps {\n  className?: string\n  node: Editor\n  path: Path\n}\n\nconst EditorNode: React.FC<EditorNodeProps> = ({ className, path }) => {\n  return (\n    <div title=\"Editor Node\" css={componentCss} className={className}>\n      <i className=\"mdi mdi-alpha-e-circle-outline\"></i>\n      <PathView path={path} />\n    </div>\n  )\n}\n\nexport default EditorNode\n",
  "/components/NodeTree/NodeTree.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Editor, Node, Element, Text, Path } from 'slate'\nimport { EditorNode, ElementNode, TextNode } from '..'\nimport { Theme } from '../../theme'\nimport { useNodeSpecContext } from '../NodeSpec'\nimport TextNodeContent from './TextNodeContent'\n\nconst componentCss = ({ textInverseColor, color: { node } }: Theme) =>\n  css`\n    background-color: ${node.backgroundColor};\n    color: ${textInverseColor};\n    font-size: 0.9em;\n  `\n\nconst selectedNodeCss = (theme: Theme) => css`\n  background-color: ${theme.barSelectedColor};\n  color: ${theme.textInverseColor};\n`\n\nexport interface NodeTreeProps {\n  className?: string\n  node: Node\n  path?: Path\n  initialIsExpanded?: boolean\n  showHighlightedLocations?: boolean\n}\n\nconst NodeTree: React.FC<NodeTreeProps> = ({\n  className,\n  node,\n  path = [],\n  initialIsExpanded = true,\n  showHighlightedLocations,\n}) => {\n  const [isExpanded, setIsExpanded] = React.useState(initialIsExpanded)\n  const chevronIconClass = isExpanded\n    ? 'mdi mdi-chevron-down'\n    : 'mdi mdi-chevron-right'\n\n  const { highlightPaths } = useNodeSpecContext()\n  const isSelected =\n    showHighlightedLocations && highlightPaths.find((p) => Path.equals(p, path))\n\n  const nodeCss = (theme: Theme) => css`\n    ${isSelected ? selectedNodeCss(theme) : undefined}\n  `\n\n  let nodeView: React.ReactNode = null\n\n  if (Editor.isEditor(node)) {\n    nodeView = <EditorNode css={nodeCss} node={node} path={path} />\n  } else if (Element.isElement(node)) {\n    nodeView = <ElementNode css={nodeCss} node={node} path={path} />\n  } else if (Text.isText(node)) {\n    nodeView = <TextNode css={nodeCss} node={node} path={path} />\n  }\n\n  return (\n    <div css={componentCss} className={className}>\n      <span\n        css={css`\n          display: flex;\n        `}\n        onClick={() => setIsExpanded((isExpanded) => !isExpanded)}\n      >\n        <i className={chevronIconClass}></i>\n        {nodeView}\n      </span>\n\n      {isExpanded && (\n        <div\n          css={css`\n            padding-left: 20px;\n          `}\n        >\n          {Text.isText(node) ? (\n            <div\n              css={(theme: Theme) => css`\n                color: ${theme.color.node.stringColor};\n                padding-left: 20px;\n                ${isSelected ? selectedNodeCss(theme) : undefined}\n              `}\n            >\n              &quot;\n              <TextNodeContent node={node} path={path} />\n              &quot;\n            </div>\n          ) : (\n            node.children.map((child, i) => {\n              const childPath = path.concat(i)\n              return (\n                <NodeTree\n                  key={childPath.join(',')}\n                  node={child}\n                  path={childPath}\n                  initialIsExpanded={initialIsExpanded}\n                  showHighlightedLocations={showHighlightedLocations}\n                />\n              )\n            })\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default NodeTree\n",
  "/components/ApiControls/ArgLabel.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Arg } from './model'\n\nconst componentCss = css``\n\nexport interface ArgLabelProps<TArg extends Arg> {\n  arg: TArg\n}\n\nconst ArgLabel = <TArg extends Arg>({ arg }: ArgLabelProps<TArg>) => {\n  return (\n    <label css={componentCss}>\n      <span className=\"argToken\">{arg.name}</span>\n      <span className=\"separatorToken\">{arg.isOptional ? '?' : ''}:&nbsp;</span>\n      <span className=\"typeToken\">{arg.type}</span>\n    </label>\n  )\n}\n\nexport default ArgLabel\n",
  "/components/ApiControls/ApiControls.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Theme } from '../../theme'\nimport ArgControl from './ArgControl'\nimport {\n  ApiFunction,\n  isFunctionArg,\n  ArgValue,\n  Arg,\n  ObjectArgValues,\n  EditorArg,\n  ObjectArg,\n  isObjectArg,\n} from './model'\nimport ObjectArgControl from './ObjectArgControl'\n\nconst componentCss = ({ code }: Theme) => css`\n  background-color: ${code.backgroundColor};\n  padding: 10px;\n  overflow-x: auto;\n  .commentBlock {\n    color: ${code.commentColor};\n  }\n  .paramToken {\n    color: ${code.paramColor};\n  }\n  .iteratorToken {\n    color: ${code.separatorColor};\n  }\n  .functionNameToken {\n    color: ${code.functionNameColor};\n  }\n  .genericsToken {\n    color: ${code.separatorColor};\n  }\n  .parenToken {\n    color: ${code.separatorColor};\n  }\n  .argToken {\n    color: ${code.argColor};\n  }\n  .separatorToken {\n    color: ${code.separatorColor};\n  }\n  .typeToken {\n    color: ${code.typeColor};\n  }\n`\n\nexport interface ApiControlsProps {\n  className?: string\n  apiFunction: ApiFunction\n  values: (ArgValue<Arg> | ObjectArgValues | undefined)[]\n  onChange: (values: (ArgValue<Arg> | ObjectArgValues | undefined)[]) => void\n}\n\nconst ApiControls: React.FC<ApiControlsProps> = ({\n  className,\n  apiFunction,\n  values,\n  onChange,\n}) => {\n  const {\n    name,\n    description,\n    generics,\n    isGenerator,\n    args,\n    returnValue,\n  } = apiFunction\n  return (\n    <pre css={componentCss} className={className}>\n      <div className=\"commentBlock\">\n        {[\n          '/**',\n          (Array.isArray(description) ? description : [description]).map(\n            (d) => `\\n * ${d}`\n          ),\n          '\\n * ',\n          ...args.map((a) => paramComment(a)),\n          returnValue.yieldsComment || returnValue.comment ? (\n            <React.Fragment key=\"returnComment\">\n              {'\\n *'}\n              {(returnValue.yieldsComment || returnValue.comment)\n                .split('\\r\\n')\n                .map(\n                  commentLine(returnValue.yieldsComment ? 'yields' : 'returns')\n                )}\n            </React.Fragment>\n          ) : (\n            ''\n          ),\n          '\\n */',\n        ]}\n      </div>\n      {isGenerator ? <span className=\"iteratorToken\">*</span> : null}\n      <span className=\"functionNameToken\">{name}</span>\n      {generics ? <span className=\"genericsToken\">{generics}</span> : null}\n      <span className=\"parenToken\">(</span>\n      <div\n        css={css`\n          padding-left: 20px;\n        `}\n      >\n        {args.map((arg, i) =>\n          arg.argType === 'object' ? (\n            <ObjectArgControl\n              key={arg.name}\n              arg={arg}\n              values={values[i] as ObjectArgValues}\n              onChange={(val) =>\n                onChange(values.slice(0, i).concat(val, values.slice(i + 1)))\n              }\n            />\n          ) : arg.argType === 'editor' ? (\n            <div key={arg.name}>\n              <span className=\"argToken\">{arg.name}</span>\n              <span className=\"separatorToken\">\n                {arg.isOptional ? '?' : ''}:&nbsp;\n              </span>\n              <span className=\"typeToken\">Editor</span>\n              <span className=\"separatorToken\">,</span>\n            </div>\n          ) : (\n            <ArgControl\n              key={arg.name}\n              arg={arg}\n              value={values[i] as ArgValue<Exclude<Arg, EditorArg>>}\n              onChange={(value) => {\n                const newValues = values.slice(0)\n                newValues.splice(\n                  i,\n                  1,\n                  isFunctionArg(arg) ? (value as any)?.[1] : value\n                )\n                onChange(newValues)\n              }}\n            />\n          )\n        )}\n      </div>\n      <span className=\"separatorToken\">): </span>\n      <span className=\"typeToken\">{returnValue.type}</span>\n    </pre>\n  )\n}\n\nexport default ApiControls\n\nfunction paramComment(\n  arg: EditorArg | Arg | ObjectArg,\n  prefix?: string\n): React.ReactNode {\n  const name = prefix ? `${prefix}.${arg.name}` : arg.name\n\n  return isObjectArg(arg) ? (\n    arg.args.map((a) => paramComment(a, name))\n  ) : (\n    <React.Fragment key={name}>\n      {(typeof arg.comment === 'string' ? [arg.comment] : arg.comment).map(\n        commentLine('param', name)\n      )}\n    </React.Fragment>\n  )\n}\n\nfunction commentLine(\n  paramType: 'returns' | 'yields' | 'param',\n  paramName?: string\n) {\n  return (comment: string, i: number) => {\n    return (\n      <React.Fragment key={`${comment}-${i}`}>\n        {'\\n'}\n        <span> * </span>\n        {i === 0 ? <span className=\"paramToken\">@{paramType}</span> : null}\n        {i === 0 && paramName ? (\n          <span className=\"argToken\"> {paramName}</span>\n        ) : null}\n        <span> {comment}</span>\n      </React.Fragment>\n    )\n  }\n}\n",
  "/components/NodeSelector/NodeSelector.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Location, Path, Point } from 'slate'\nimport { Modal, NodeSpec } from '..'\nimport { Theme } from '../../theme'\nimport { useOffClickCallback } from '../../util/useOffClick.hook'\n\nconst componentCss = (theme: Theme) => css`\n  .mdi.mdi-chevron-down {\n    color: ${theme.placeholderColor};\n    font-size: 19px;\n    margin-right: -1px;\n  }\n`\n\nexport type NodeSelectorProps<TMode extends 'path' | 'point'> = {\n  mode: TMode\n  placeholder?: string\n  value?: TMode extends 'path' ? Path : Point\n  onChange: (value?: TMode extends 'path' ? Path : Point) => void\n}\n\nconst NodeSelector = <TMode extends 'path' | 'point'>({\n  mode,\n  placeholder,\n  value,\n  onChange,\n}: NodeSelectorProps<TMode>) => {\n  const [isOpen, setIsOpen] = React.useState(false)\n  const valueStr = React.useMemo(() => JSON.stringify(value) ?? '', [value])\n  const [triggerEl, setTriggerEl] = React.useState<HTMLSpanElement | null>(null)\n\n  const highlightedLocations = React.useMemo<Location[]>(() => {\n    return value ? [value] : []\n  }, [value])\n\n  const onClickInput = React.useCallback(() => {\n    setIsOpen((isOpen) => !isOpen)\n  }, [])\n\n  const onClear = React.useCallback(() => {\n    setIsOpen(false)\n    onChange(undefined)\n  }, [onChange])\n\n  useOffClickCallback(\n    triggerEl,\n    React.useCallback(() => {\n      setIsOpen(false)\n    }, [])\n  )\n\n  const onSelect = React.useCallback(\n    (pathOrPoint: TMode extends 'path' ? Path : Point) => {\n      onChange(pathOrPoint)\n      setIsOpen(false)\n    },\n    [onChange]\n  )\n\n  return (\n    <div css={componentCss}>\n      <span\n        ref={setTriggerEl}\n        css={css`\n          align-items: center;\n          display: flex;\n          position: relative;\n        `}\n      >\n        <input\n          css={(theme: Theme) => css`\n            cursor: pointer;\n            width: 100%;\n            ::placeholder {\n              color: ${theme.placeholderColor};\n            }\n          `}\n          placeholder={\n            placeholder ?? `Select ${mode === 'path' ? 'Path' : 'Point'}...`\n          }\n          type=\"text\"\n          readOnly={true}\n          value={valueStr}\n          onClick={onClickInput}\n        />\n\n        <span\n          css={css`\n            position: absolute;\n            right: 0;\n          `}\n        >\n          <i\n            className={`mdi mdi-${value ? 'close' : 'chevron-down'}`}\n            onClick={value ? onClear : onClickInput}\n          ></i>\n        </span>\n      </span>\n      {isOpen && triggerEl && (\n        <Modal targetElement={triggerEl}>\n          <NodeSpec\n            css={(theme: Theme) => css`\n              background-color: #fff;\n              border: 1px solid ${theme.placeholderColor};\n              border-radius: 4px;\n              height: 250px;\n            `}\n            mode={mode}\n            highlightLocations={highlightedLocations}\n            onSelect={onSelect as any}\n          />\n        </Modal>\n      )}\n    </div>\n  )\n}\n\nexport default NodeSelector\n",
  "/components/Modal/Modal.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nexport interface ModalProps {\n  targetElement: HTMLElement\n}\n\nconst Modal: React.FC<ModalProps> = ({ children, targetElement }) => {\n  const { bottom, left } = React.useMemo(\n    () => targetElement.getBoundingClientRect(),\n    [targetElement]\n  )\n\n  return ReactDOM.createPortal(\n    <div\n      css={css`\n        position: absolute;\n        top: ${bottom + window.scrollY}px;\n        left: 0;// ${left + window.scrollX}px;\n      `}\n    >\n      {children}\n    </div>,\n    document.body\n  )\n}\n\nexport default Modal\n",
  "/components/ApiView/ApiView.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport {\n  Editable,\n  RenderElementProps,\n  RenderLeafProps,\n  useSlate,\n} from 'slate-react'\nimport { useNodeSpecContext } from '..'\nimport { ApiControls } from '..'\nimport { asArray } from '../../util/data'\nimport { filterToLocations } from '../../util/slateUtil'\nimport { ApiFunction, useArgValues } from '../ApiControls/model'\nimport ApiResult from '../ApiResult/ApiResult'\nimport NodeTree from '../NodeTree/NodeTree'\n\nconst componentCss = css``\n\nexport interface ApiViewProps {\n  title: string\n  renderElement: (props: RenderElementProps) => JSX.Element\n  renderLeaf: (props: RenderLeafProps) => JSX.Element\n  initialApiFunction: ApiFunction\n  apiFunctions: Record<string, ApiFunction>\n}\n\nconst ApiView: React.FC<ApiViewProps> = ({\n  title,\n  renderElement,\n  renderLeaf,\n  initialApiFunction,\n  apiFunctions,\n}) => {\n  const editor = useSlate()\n  const { selection } = editor\n  const { setHighlightLocations } = useNodeSpecContext()\n\n  const apiFunctionList = React.useMemo(\n    () => Object.keys(apiFunctions).map((name) => apiFunctions[name]),\n    [apiFunctions]\n  )\n  const [apiFunction, setApiFunction] = React.useState(initialApiFunction)\n  const { values, setValues, resetValues } = useArgValues(apiFunction.args)\n  const [result, setResult] = React.useState<unknown[]>([])\n  const [runId, setRunId] = React.useState(0)\n\n  const intervalRef = React.useRef<number>()\n\n  React.useEffect(() => {\n    if (selection) {\n      setHighlightLocations([selection])\n    }\n  }, [selection, setHighlightLocations])\n\n  const onClick = React.useCallback(\n    (event: React.MouseEvent) => {\n      event.preventDefault()\n\n      let result\n      try {\n        result = apiFunction.fn(...values)\n        result = asArray(result)\n\n        if (apiFunction.returnValue.type === 'Path') {\n          result = [result]\n        }\n      } catch (err) {\n        console.error(err)\n        result = [String(err)]\n      }\n\n      setResult(result)\n      setRunId((id) => id + 1)\n      setHighlightLocations(selection ? [selection] : [])\n\n      if (Array.isArray(result)) {\n        const locations = filterToLocations(result)\n        if (selection) {\n          locations.unshift(selection)\n        }\n\n        window.clearInterval(intervalRef.current)\n\n        let i = 0\n        intervalRef.current = window.setInterval(() => {\n          if (++i <= locations.length) {\n            setHighlightLocations(locations.slice(0, i))\n          } else {\n            window.clearInterval(intervalRef.current)\n          }\n        }, 500)\n      }\n    },\n    [apiFunction, values, selection, setHighlightLocations]\n  )\n\n  const onApiFunctionChange = React.useCallback(\n    ({ currentTarget }: React.ChangeEvent<HTMLSelectElement>) => {\n      const apiFunction = apiFunctions[currentTarget.value]\n      setApiFunction(apiFunction)\n      resetValues(apiFunction.args)\n    },\n    [apiFunctions, resetValues]\n  )\n\n  return (\n    <div css={componentCss}>\n      <h1>{title} Interface</h1>\n      <select value={apiFunction.name} onChange={onApiFunctionChange}>\n        {apiFunctionList.map((fn) => (\n          <option key={fn.name} value={fn.name}>\n            {title}.{fn.name}\n          </option>\n        ))}\n      </select>\n\n      <h2>Editor</h2>\n      <Editable\n        css={css`\n          font-size: 0.9em;\n        `}\n        renderElement={renderElement}\n        renderLeaf={renderLeaf}\n      />\n\n      <h2>API</h2>\n      <ApiControls\n        css={css`\n          font-size: 0.8em;\n        `}\n        apiFunction={apiFunction}\n        values={values}\n        onChange={setValues}\n      />\n      <button onClick={onClick}>Run</button>\n\n      <div\n        css={css`\n          display: flex;\n          > * {\n            flex: 1 1 50%;\n          }\n          @media (max-width: 768px) {\n            flex-direction: column;\n            .no-mobile {\n              display: none;\n            }\n          }\n        `}\n      >\n        <div>\n          <h2>Results</h2>\n          {runId ? (\n            <div>\n              <ApiResult runId={String(runId)} data={result} />\n            </div>\n          ) : null}\n        </div>\n        <div>\n          <h2>Data Model</h2>\n          <NodeTree node={editor} showHighlightedLocations={true} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default ApiView\n",
  "/components/ApiResult/ApiResult.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Editor, Node, Path } from 'slate'\nimport { Theme } from '../../theme'\nimport { isNodeEntry } from '../../util/slateUtil'\nimport { NodeTree } from '..'\nimport { useSlate } from 'slate-react'\nimport PathView from '../PathView/PathView'\n\nconst componentCss = css``\n\nexport interface ApiResultProps {\n  runId: string\n  data: unknown[]\n}\n\nconst ApiResult: React.FC<ApiResultProps> = ({ data, runId }) => {\n  const editor = useSlate()\n\n  return (\n    <div css={componentCss}>\n      <pre\n        css={({ code, textInverseColor }: Theme) => css`\n          background-color: ${code.backgroundColor};\n          color: ${textInverseColor};\n          max-height: 400px;\n          overflow-y: auto;\n        `}\n      >\n        {data.map((datum, i) => {\n          return (\n            <span\n              css={css`\n                display: flex;\n              `}\n              key={`${runId}-${i}`}\n            >\n              <span\n                css={css`\n                  flex-shrink: 0;\n                  margin-right: 10px;\n                  text-align: right;\n                  width: 20px;\n                `}\n              >\n                {i + 1}\n              </span>\n              {datumView(editor, datum)}\n            </span>\n          )\n        })}\n      </pre>\n    </div>\n  )\n}\n\nexport default ApiResult\n\nfunction datumView(editor: Editor, datum: unknown) {\n  if (isNodeEntry(datum)) {\n    return (\n      <NodeTree node={datum[0]} path={datum[1]} initialIsExpanded={false} />\n    )\n  } else if (Path.isPath(datum)) {\n    return <PathView path={datum} />\n  } else if (Node.isNode(datum)) {\n    const [[, path]] = Node.nodes(editor, {\n      pass: ([n]) => n !== datum,\n    })\n\n    return <NodeTree node={datum} path={path} initialIsExpanded={false} />\n  }\n\n  return JSON.stringify(datum) ?? 'undefined'\n}\n",
  "/components/App/index.ts": "export { default as App } from './App'",
  "/components/NodeSpec/index.ts": "export { default as NodeSpec } from './NodeSpec'\nexport type { NodeSpecProps } from './NodeSpec'\n\nexport { default as NodeSpecContainer } from './NodeSpecContainer'\nexport type { NodeSpecContainerProps } from './NodeSpecContainer'\n\nexport * from './NodeSpecContext'\n",
  "/components/Editor/index.ts": "export { default as Editor } from './Editor'",
  "/util/slateUtil.ts": "import { Location, Node, NodeEntry, Path, Point, Range } from 'slate'\n\nexport function isNodeEntry(datum: unknown): datum is NodeEntry<Node> {\n  return (\n    Array.isArray(datum) &&\n    datum.length === 2 &&\n    Node.isNode(datum[0]) &&\n    Path.isPath(datum[1])\n  )\n}\n\nexport function filterToLocations(data: unknown[]): Location[] {\n  const locations: Location[] = []\n\n  for (const datum of data) {\n    if (isNodeEntry(datum)) {\n      locations.push(datum[1])\n    } else if (Path.isPath(datum)) {\n      locations.push(datum)\n    } else if (Point.isPoint(datum)) {\n      locations.push(datum)\n    } else if (Range.isRange(datum)) {\n      locations.push(datum)\n    }\n  }\n\n  return locations\n}\n\nexport function siftLocations(\n  locations: Location[]\n): { paths: Path[]; points: Point[]; ranges: Range[] } {\n  const paths: Path[] = []\n  const points: Point[] = []\n  const ranges: Range[] = []\n\n  for (const location of locations) {\n    if (Path.isPath(location)) {\n      paths.push(location)\n    } else if (Point.isPoint(location)) {\n      points.push(location)\n    } else if (Range.isRange(location)) {\n      ranges.push(location)\n    }\n  }\n\n  return {\n    paths,\n    points,\n    ranges,\n  }\n}\n\n/**\n * Return a ordered, labeled range\n */\nexport function toLabeledRange(\n  range: Range\n): [{ label: string; point: Point }, { label: string; point: Point }] {\n  const anchor = { label: 'anchor', point: range.anchor }\n  const focus = { label: 'focus', point: range.focus }\n\n  return Range.isForward(range) ? [anchor, focus] : [focus, anchor]\n}\n",
  "/util/useOffClick.hook.ts": "import React from 'react'\n\nexport function useOffClickCallback(\n  ignoreElement: HTMLElement | null,\n  callback: () => void\n): void {\n  React.useEffect(() => {\n    function offClick(event: MouseEvent) {\n      if (\n        ignoreElement?.contains(event.target as Node) ||\n        (event.target as Element).classList.contains('ignore-off-click')\n      ) {\n        return\n      }\n      callback()\n    }\n\n    document.addEventListener('click', offClick)\n    return () => {\n      document.removeEventListener('click', offClick)\n    }\n  }, [ignoreElement, callback])\n}\n",
  "/util/data.ts": "import { isNodeEntry } from './slateUtil'\n\nexport function asArray(data: any): unknown[] {\n  if (isNodeEntry(data)) {\n    return [data]\n  }\n\n  if (Array.isArray(data)) {\n    return data\n  }\n\n  if (data && typeof data[Symbol.iterator] === 'function') {\n    return [...data]\n  }\n\n  return [data]\n}\n",
  "/components/ApiControls/ObjectArgControl.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Theme } from '../../theme'\nimport ArgControl from './ArgControl'\nimport {\n  Arg,\n  ArgValue,\n  isFunctionArg,\n  ObjectArg,\n  ObjectArgValues,\n} from './model'\n\nconst componentCss = ({ code }: Theme) => css`\n  .argToken {\n    color: ${code.argColor};\n  }\n  .separatorToken {\n    color: ${code.separatorColor};\n  }\n  .braceToken {\n    color: ${code.separatorColor};\n  }\n`\n\nexport interface ObjectArgControlProps {\n  arg: ObjectArg\n  values: ObjectArgValues\n  onChange: (values: ObjectArgValues) => void\n}\n\nconst ObjectArgControl: React.FC<ObjectArgControlProps> = ({\n  arg: obj,\n  values,\n  onChange,\n}) => {\n  // const [values, setValues] = React.useState(() => {\n  //   const values: ObjectArgValues = {}\n\n  //   for (const arg of obj.args) {\n  //     const value = isFunctionArg(arg) ? arg.value?.[1] : arg.value\n  //     values[arg.name] = value\n  //   }\n\n  //   return values\n  // })\n\n  // const onChangeInternal = React.useCallback(\n  //   function (value: ArgValue<Arg>) {\n  //     const newValues = {\n  //       ...values,\n  //       [arg.name]: isFunctionArg(arg) ? arg.value?.[1] : arg.value,\n  //     }\n\n  //     // setValues(newValues)\n  //     onChange(newValues)\n  //   },\n  //   [values, onChange]\n  // )\n\n  return (\n    <div css={componentCss}>\n      <span className=\"argToken\">{obj.name}</span>\n      <span className=\"separatorToken\">{obj.isOptional ? '?' : ''}:</span>\n      <span className=\"braceToken\">{' {'}</span>\n      <div\n        css={css`\n          padding-left: 20px;\n        `}\n      >\n        {obj.args.map((arg) => (\n          <ArgControl\n            key={arg.name}\n            arg={arg}\n            value={values[arg.name]}\n            onChange={<TArg extends Arg>(value?: ArgValue<TArg>) => {\n              const newValues = {\n                ...values,\n                [arg.name]: isFunctionArg(arg) ? (value as any)?.[1] : value,\n              }\n\n              onChange(newValues)\n            }}\n          />\n        ))}\n      </div>\n      <span className=\"braceToken\">{'}'}</span>\n    </div>\n  )\n}\n\nexport default ObjectArgControl\n",
  "/components/ApiControls/ArgControl.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { Editor, Node, Path, Point } from 'slate'\nimport { useSlate, ReactEditor } from 'slate-react'\nimport { ArgLabel, Selector } from '..'\nimport { Theme } from '../../theme'\nimport NodeSelector from '../NodeSelector/NodeSelector'\nimport {\n  Arg,\n  ArgValue,\n  isBooleanArg,\n  isFunctionArg,\n  isNumberArg,\n  isNodeArg,\n  isPathArg,\n  isPointArg,\n  isStringArg,\n  isStringLiteralArg,\n} from './model'\n\nconst componentCss = ({ code }: Theme) =>\n  css`\n    .argToken {\n      color: ${code.argColor};\n    }\n    .separatorToken {\n      color: ${code.separatorColor};\n    }\n    .typeToken {\n      color: ${code.typeColor};\n    }\n  `\n\nexport interface ArgControlProps<TArg extends Arg> {\n  arg: TArg\n  value?: ArgValue<TArg>\n  onChange: (value?: ArgValue<TArg>) => void\n}\n\nconst ArgControl = <TArg extends Arg>({\n  arg,\n  value,\n  onChange,\n}: ArgControlProps<TArg>) => {\n  const editor = useSlate()\n\n  let children: React.ReactNode = (\n    <span\n      css={css`\n        color: #fff;\n      `}\n    >\n      'N/A'\n    </span>\n  )\n\n  if (isPathArg(arg)) {\n    children = (\n      <NodeSelector\n        mode=\"path\"\n        value={value as Path}\n        onChange={onChange as (value?: Path) => void}\n      />\n    )\n  } else if (isPointArg(arg)) {\n    children = (\n      <NodeSelector\n        mode=\"point\"\n        value={value as Point}\n        onChange={onChange as (value?: Point) => void}\n      />\n    )\n  } else if (isNodeArg(arg)) {\n    const path = Node.isNode(value)\n      ? ReactEditor.findPath(editor, value)\n      : value\n    children = (\n      <NodeSelector\n        mode=\"path\"\n        value={path as Path}\n        onChange={(value) => {\n          onChange((value ? Editor.node(editor, value)[0] : undefined) as any)\n        }}\n      />\n    )\n  } else if (\n    isStringLiteralArg(arg) ||\n    isBooleanArg(arg) ||\n    isFunctionArg(arg)\n  ) {\n    children = (\n      <Selector\n        label={arg.name}\n        options={arg.options}\n        value={value as string | boolean | [string, Function]}\n        onChange={\n          onChange as (value?: string | boolean | [string, Function]) => void\n        }\n      />\n    )\n  } else if (isNumberArg(arg) || isStringArg(arg)) {\n    const cast = isNumberArg(arg)\n      ? function (value: string) {\n          const result = value === '' ? NaN : Number(value)\n          return isNaN(result) ? undefined : result\n        }\n      : String\n    children = (\n      <input\n        type=\"text\"\n        value={String(value ?? '')}\n        onChange={({ currentTarget }) => {\n          ;(onChange as (value?: number | string) => void)(\n            cast(currentTarget.value)\n          )\n        }}\n      />\n    )\n  }\n\n  return (\n    <div css={componentCss}>\n      <div\n        css={css`\n          display: flex;\n        `}\n      >\n        <ArgLabel arg={arg} />\n        &nbsp;\n        {children}\n      </div>\n    </div>\n  )\n}\n\nexport default ArgControl\n",
  "/components/App/App.tsx": "import React from 'react';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      App\n    </div>\n  );\n}\n\nexport default App;\n",
  "/stories/Editor/EditorWithDecorations.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport { createEditor, Node, NodeEntry, Range, Text } from 'slate'\nimport {\n  DefaultLeaf,\n  Editable,\n  RenderLeafProps,\n  Slate,\n  withReact,\n} from 'slate-react'\nimport SourceLink from '../SourceLink'\nimport { useConsoleRef } from './useConsoleRef.hook'\n\nconst componentCss = css`\n  [contenteditable='true'] {\n    border: 1px solid #ccc;\n    padding: 4px;\n  }\n\n  .header {\n    display: flex;\n    justify-content: space-between;\n    margin-top: 10px;\n  }\n\n  pre {\n    background-color: #333;\n    color: #fff;\n    height: 250px;\n    margin: 0;\n    padding: 10px;\n    overflow-y: auto;\n  }\n`\n\nexport interface EditorWithDecorationsProps {\n  initialValue: Node[]\n}\n\nconst EditorWithDecorations: React.FC<EditorWithDecorationsProps> = ({\n  initialValue,\n}) => {\n  /** Setup logging */\n  const { logToConsole, clearConsole, Console } = useConsoleRef()\n  logToConsole('render component')\n\n  /** If we change the initialValue in Storybook controls, reset things */\n  React.useEffect(() => {\n    setValue(initialValue)\n  }, [clearConsole, initialValue])\n\n  const editor = React.useMemo(() => withReact(createEditor()), [])\n  const [value, setValue] = React.useState<Node[]>(initialValue)\n\n  /** Track when decorate is called by logging node paths */\n  const decorate = React.useCallback(\n    ([node, path]: NodeEntry<Node>) => {\n      const ranges: Range[] = []\n\n      if (Text.isText(node)) {\n        logToConsole(`decorate: ${JSON.stringify(path)} \"${Node.string(node)}\"`)\n\n        // testing 2 arbitrary decorations on different ranges\n        ranges.push({\n          anchor: { path, offset: 0 },\n          focus: { path, offset: node.text.length },\n          isAny: true,\n        })\n        ranges.push({\n          anchor: { path, offset: 0 },\n          focus: { path, offset: 1 },\n          isFirst: 'Y',\n        })\n      } else {\n        logToConsole(`decorate: ${JSON.stringify(path)}`)\n      }\n\n      return ranges\n    },\n    [logToConsole]\n  )\n\n  const renderLeaf = React.useCallback(\n    (props: RenderLeafProps) => {\n      logToConsole(`renderLeaf: ${JSON.stringify(props.leaf)}`)\n      return <DefaultLeaf {...props} />\n    },\n    [logToConsole]\n  )\n\n  /** Track what type of changes occur */\n  const onChange = React.useCallback(\n    (newValue) => {\n      logToConsole(`onChange: ${newValue === value ? 'selection' : 'document'}`)\n      setValue(newValue)\n    },\n    [logToConsole, value]\n  )\n\n  return (\n    <div css={componentCss}>\n      <Slate editor={editor} value={value} onChange={onChange}>\n        <Editable\n          decorate={decorate}\n          spellCheck={false}\n          placeholder=\"Type to see when decorate function is called...\"\n          renderLeaf={renderLeaf}\n        />\n      </Slate>\n\n      <Console />\n      <SourceLink path={'src/stories/Editor/EditorWithDecorations.tsx#L42'} />\n    </div>\n  )\n}\n\nexport default EditorWithDecorations\n",
  "/components/NodeSpec/NodeSpec.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Point,\n  Range,\n  Text,\n} from 'slate'\nimport { useSlate } from 'slate-react'\nimport { Theme } from '../../theme'\nimport { siftLocations } from '../../util/slateUtil'\n\nconst componentCss = css`\n  display: flex;\n  flex-direction: column;\n\n  header {\n    border-bottom: 1px solid #333;\n    padding: 0 10px;\n  }\n  main {\n    overflow-y: auto;\n    padding: 0 10px;\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n  header > span:nth-of-type(1) {\n    margin-right: 20px;\n  }\n  li > span:nth-of-type(1) {\n    margin-right: 40px;\n  }\n  .anchor,\n  .focus,\n  .point {\n    border-right: 2px solid;\n    position: absolute;\n    height: 1.2em;\n  }\n  .anchor {\n    border-color: green;\n    background-color: green;\n  }\n  .focus {\n    border-color: red;\n    background-color: red;\n  }\n  .point {\n    border-color: blue;\n    background-color: blue;\n  }\n`\n\nconst selectedNodeCss = (theme: Theme) => css`\n  background-color: ${theme.barSelectedColor};\n  color: ${theme.textInverseColor};\n`\n\nconst hoverCss = (theme: Theme) => css`\n  :hover:not(.selected) {\n    background-color: rgb(0, 0, 0, 0.05);\n    color: ${theme.textColor};\n    cursor: pointer;\n  }\n`\n\nexport interface NodeSpecProps {\n  className?: string\n  rootNode?: Node\n  mode: 'path' | 'point'\n  onSelect?: (pointOrPoint: Path | Point) => void\n  highlightLocations?: Location[]\n}\n\nconst NodeSpec: React.FC<NodeSpecProps> = ({\n  className,\n  rootNode,\n  mode,\n  highlightLocations = [],\n  onSelect,\n}) => {\n  const editor = useSlate()\n  const nodeEntries = [...Node.nodes(rootNode ?? editor)]\n\n  const {\n    paths: highlightPaths,\n    points: highlightPoints,\n    ranges: highlightRanges,\n  } = React.useMemo(() => siftLocations(highlightLocations), [\n    highlightLocations,\n  ])\n\n  const labeledPoints = React.useMemo(\n    () =>\n      highlightRanges\n        .map(toLabeledRange)\n        .flat()\n        .concat(highlightPoints.map((point) => ({ label: 'point', point }))),\n    [highlightRanges, highlightPoints]\n  )\n\n  const onClickNode = React.useCallback(\n    ([node, path]: NodeEntry<Node>) => {\n      if (mode === 'path') {\n        onSelect?.(path)\n        return\n      }\n\n      const { anchorNode, anchorOffset } = document.getSelection() ?? {}\n      let offset = 0\n\n      if (Text.isText(node) && anchorNode) {\n        const spanElement = anchorNode.parentElement\n\n        if (spanElement?.classList.contains('text-token')) {\n          const nodeText = anchorNode.textContent\n          const containerText = spanElement?.parentElement?.textContent\n\n          if (nodeText && containerText) {\n            offset = containerText.lastIndexOf(nodeText) + anchorOffset!\n          }\n        }\n      }\n\n      onSelect?.({\n        path,\n        offset,\n      })\n    },\n    [mode, onSelect]\n  )\n\n  return (\n    <div css={componentCss} className={className}>\n      <header>\n        <span>Path</span>\n        <span>Node</span>\n      </header>\n      <main>\n        <ul>\n          {nodeEntries.map(([node, path]) => {\n            const isSelected = highlightPaths.find((p) => Path.equals(p, path))\n            return (\n              <li\n                css={(theme: Theme) => css`\n                  display: flex;\n                  ${mode === 'path' && onSelect && hoverCss(theme)}\n                  ${isSelected ? selectedNodeCss(theme) : undefined}\n                `}\n                className={isSelected ? 'selected' : undefined}\n                key={JSON.stringify(path)}\n                onClick={() => onClickNode([node, path])}\n              >\n                <span>\n                  {JSON.stringify(path)}\n                  {pathToSpace(path, 4)}\n                </span>\n                <span\n                  css={css`\n                    position: relative;\n                  `}\n                >\n                  {nodeSpec(mode, [node, path], labeledPoints)}\n                </span>\n              </li>\n            )\n          })}\n        </ul>\n      </main>\n    </div>\n  )\n}\n\nexport default NodeSpec\n\nfunction nodeTokens(\n  [node, path]: NodeEntry<Node>,\n  points: { label: string; point: Point }[]\n): (string | { label: string })[] {\n  const nodeText = Node.string(node)\n  const tokens: (string | { label: string })[] = []\n\n  // filter down to only points in current path\n  const pointsInPath = points.filter(({ point }) =>\n    Path.equals(point.path, path)\n  )\n\n  let i = 0\n\n  // tokenize text using any points that apply\n  for (const { label, point } of pointsInPath) {\n    const { offset } = point\n\n    if (offset > i) {\n      tokens.push(nodeText.substr(i, offset - i))\n      i = offset\n    }\n\n    tokens.push({\n      label,\n    })\n  }\n\n  if (i < nodeText.length) {\n    tokens.push(nodeText.substr(i))\n  }\n\n  return tokens\n}\n\n/** Return a ordered, labeled range */\nfunction toLabeledRange(\n  range: Range\n): [{ label: string; point: Point }, { label: string; point: Point }] {\n  const anchor = { label: 'anchor', point: range.anchor }\n  const focus = { label: 'focus', point: range.focus }\n\n  return Range.isForward(range) ? [anchor, focus] : [focus, anchor]\n}\n\nfunction nodeSpec(\n  mode: 'path' | 'point',\n  [node, path]: NodeEntry<Node>,\n  labeledPoints: { label: string; point: Point }[] = []\n): React.ReactNode {\n  if (Editor.isEditor(node)) {\n    return 'editor'\n  }\n\n  if (Element.isElement(node)) {\n    return `type:${node.type ?? ''}`\n  }\n\n  if (Text.isText(node)) {\n    const tokens = nodeTokens([node, path], labeledPoints)\n\n    return (\n      <span\n        css={\n          mode === 'point' &&\n          css`\n            :hover {\n              background-color: #1fa8fd;\n            }\n          `\n        }\n        className=\"text-node-content\"\n      >\n        {tokens.map((token, i) =>\n          typeof token === 'string' ? (\n            <span\n              css={\n                mode === 'point' &&\n                css`\n                  cursor: text;\n                `\n              }\n              className=\"text-token\"\n              key={i}\n            >\n              {token}\n            </span>\n          ) : (\n            <span\n              title={token.label}\n              css={(theme: Theme) => css`\n                position: relative;\n                span {\n                  background-color: inherit;\n                  color: ${theme.textInverseColor};\n                  position: absolute;\n                  top: -8px;\n                  font-size: 10px;\n                  padding: 0 4px;\n                }\n              `}\n              key={i}\n              className={token.label}\n            >\n              <span>{token.label.substr(0, 1)}</span>\n            </span>\n          )\n        )}\n      </span>\n    )\n  }\n\n  return 'unknown'\n}\n\nfunction pathToSpace(path: Path, spacesPerLevel: number = 2) {\n  const spaces = []\n  for (let i = 0; i < path.length * spacesPerLevel; ++i) {\n    spaces.push('\\xa0')\n  }\n  return spaces.join('')\n}\n",
  "/components/NodeSpec/NodeSpecContext.ts": "import React from 'react'\nimport { Location } from 'slate'\nimport { siftLocations, toLabeledRange } from '../../util/slateUtil'\n\ninterface NodeSpecContextValue {\n  highlightLocations: Location[]\n  setHighlightLocations: (\n    locations: Location[] | ((locations: Location[]) => Location[])\n  ) => void\n}\n\nconst NodeSpecContext = React.createContext<NodeSpecContextValue>(\n  (null as unknown) as NodeSpecContextValue\n)\n\nexport const NodeSpecContextProvider = NodeSpecContext.Provider\n\nexport function useNodeSpecContext() {\n  const { highlightLocations, setHighlightLocations } = React.useContext(\n    NodeSpecContext\n  )\n\n  const {\n    paths: highlightPaths,\n    points: highlightPoints,\n    ranges: highlightRanges,\n  } = React.useMemo(() => siftLocations(highlightLocations), [\n    highlightLocations,\n  ])\n\n  const labeledPoints = React.useMemo(\n    () =>\n      highlightRanges\n        .map(toLabeledRange)\n        .flat()\n        .concat(highlightPoints.map((point) => ({ label: 'point', point }))),\n    [highlightRanges, highlightPoints]\n  )\n\n  return {\n    highlightLocations,\n    setHighlightLocations,\n    highlightPaths,\n    highlightPoints,\n    highlightRanges,\n    labeledPoints,\n  }\n}\n",
  "/components/NodeSpec/NodeSpecContainer.tsx": "import React from 'react'\nimport { useSlate } from 'slate-react'\nimport { NodeSpec, useNodeSpecContext } from '.'\n\nexport interface NodeSpecContainerProps {\n  className?: string\n}\n\nconst NodeSpecContainer: React.FC<NodeSpecContainerProps> = ({ className }) => {\n  const { selection } = useSlate()\n  const { highlightLocations } = useNodeSpecContext()\n\n  const highlightLocationsWithSelection = React.useMemo(\n    () => (selection ? [selection, ...highlightLocations] : highlightLocations),\n    [selection, highlightLocations]\n  )\n\n  return (\n    <NodeSpec\n      className={className}\n      mode=\"path\"\n      highlightLocations={highlightLocationsWithSelection}\n    />\n  )\n}\n\nexport default NodeSpecContainer\n",
  "/components/Editor/Editor.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\nimport {\n  createEditor,\n  Editor as SlateEditor,\n  Node,\n  NodeEntry,\n  Range,\n} from 'slate'\nimport {\n  Editable,\n  ReactEditor,\n  RenderLeafProps,\n  Slate,\n  withReact,\n} from 'slate-react'\nimport { Plugin, withPlugins } from './withPlugins'\n\nconst componentCss = css`\n  border: 1px solid #ccc;\n`\n\nexport interface EditorProps {\n  initialValue: Node[]\n  plugins?: Plugin<SlateEditor & ReactEditor>[]\n  createDecorate?: <TEditor extends SlateEditor>(\n    editor: TEditor\n  ) => (entry: NodeEntry<Node>) => Range[]\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n}\n\nconst Editor: React.FC<EditorProps> = ({\n  initialValue,\n  plugins = [],\n  createDecorate,\n  renderLeaf,\n}) => {\n  const editor = React.useMemo(\n    () => withPlugins(withReact, ...plugins)(createEditor()),\n    [plugins]\n  )\n\n  const [value, setValue] = React.useState<Node[]>(initialValue)\n  // console.log(JSON.stringify(value, undefined, 2))\n  console.log(JSON.stringify(editor.selection, undefined, 2))\n  return (\n    <div css={componentCss}>\n      <Slate editor={editor} value={value} onChange={setValue}>\n        <Editable\n          decorate={createDecorate && createDecorate(editor)}\n          renderLeaf={renderLeaf}\n          spellCheck={false}\n        />\n      </Slate>\n    </div>\n  )\n}\n\nexport default Editor\n",
  "/stories/SourceLink.tsx": "/** @jsx jsx */\nimport { css, jsx } from '@emotion/core'\n\nimport React from 'react'\n\nconst componentCss = css``\n\nexport interface SourceLinkProps {\n  path: string\n}\n\nconst SourceLink: React.FC<SourceLinkProps> = ({ path }) => {\n  return (\n    <a\n      css={componentCss}\n      href={`https://github.com/emeraldwalk/slate-storybook/blob/master/${path}`}\n      rel=\"noopener noreferrer\"\n      target=\"_blank\"\n    >\n      Source\n    </a>\n  )\n}\n\nexport default SourceLink\n",
  "/stories/Editor/useConsoleRef.hook.tsx": "import React from 'react'\n\n/**\n * Hook for logging console output to an HTML element.\n * Uses refs + native DOM api so that a React render isn't required\n * for updating the console.\n *\n * @returns a Console component + some functions to manipulate it.\n */\nexport function useConsoleRef() {\n  const linesRef = React.useRef<string[]>([])\n  const consoleRef = React.useRef<HTMLPreElement>(null)\n\n  const flushDebounceRef = React.useRef<NodeJS.Timeout>()\n  const flush = React.useCallback(() => {\n    clearTimeout(flushDebounceRef.current!)\n    flushDebounceRef.current = setTimeout(() => {\n      linesRef.current.push(\n        '---------------- console flush --------------------'\n      )\n\n      if (consoleRef.current) {\n        consoleRef.current.innerText = linesRef.current\n          .map((line, i) => `${i + 1}: ${line}`)\n          .join('\\n')\n\n        consoleRef.current.scrollTop = consoleRef.current.scrollHeight\n      }\n    }, 250)\n  }, [])\n\n  const logToConsole = React.useCallback(\n    (line: string) => {\n      linesRef.current.push(line)\n      flush()\n    },\n    [flush]\n  )\n\n  const clearConsole = React.useCallback(() => {\n    linesRef.current.length = 0\n    if (consoleRef.current) {\n      consoleRef.current.innerText = ''\n    }\n  }, [])\n\n  React.useEffect(() => {\n    flush()\n  }, [flush])\n\n  const Console = React.useMemo(\n    () => () => (\n      <div>\n        <header className=\"header\">\n          <span>Console</span>\n          <button className=\"clear-console\" onClick={clearConsole}>\n            Clear\n          </button>\n        </header>\n\n        <pre ref={consoleRef}></pre>\n      </div>\n    ),\n    [clearConsole]\n  )\n\n  return {\n    clearConsole,\n    logToConsole,\n    Console,\n  }\n}\n",
  "/components/Editor/withPlugins.ts": "import { Editor } from 'slate'\n\nexport type Plugin<\n  TEditorA extends Editor = Editor,\n  TEditorB extends Editor = TEditorA\n> = (editor: TEditorA) => TEditorB\n\n/**\n * Composes a list of withXxx plugin functions.\n *\n * Creating a fully type aware pipe function gets really crazy,\n * so compromising by letting first function determine the input / ouput\n * type of subsequent functions. This lets us do something like:\n *\n * // editor will be of type (Editor & ReactEditor)\n * // based on first arg withReact\n * const editor = withPlugins(\n *   withReact,\n *   pluginA,\n *   pluginB\n * )(createEditor())\n */\nexport function withPlugins<TEditorA extends Editor, TEditorB extends Editor>(\n  pluginA: Plugin<TEditorA, TEditorB>,\n  ...plugins: Plugin<TEditorB>[]\n): Plugin<TEditorA, TEditorB> {\n  return function piped(editorA: TEditorA) {\n    const editorB = pluginA(editorA)\n    return plugins.reduce((memo, func) => func(memo), editorB)\n  }\n}\n"
}